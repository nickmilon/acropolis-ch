
  async buildTiny() {
    const tbTiny = 'twitter.tiny';
    let dt = new Date(); dt.setMilliseconds(0); dt = dt.getTime() / 1000;
    let data = [
      [1, 2, 1, dt],
      [1, 3, 1, dt],
      [1, 3, -1, dt],   // cancel
      [3, 1, 1, dt],    // canceled mutual
      [1, 4, 1, dt],
      [4, 1, 1, dt],    // mutual
      [2, 3, 1, dt],
      [3, 4, 1, dt],
    ];
    data = data.map((el) => `(${el})`).join('');
    await this.client.request(sql.DROP_TABLE(undefined, tbTiny));
    await this.client.request(sql.CREATE_TABLE_fromSchema(undefined, tbTiny, this.gSql.structEdges()));
    const sqlStr = sql.INSERT_INTO(undefined, tbTiny, data, { columns: '', FORMAT: 'Values' });
    const result = await this.client.request(sqlStr);
    logger.inspectIt(result);
  }


  async buildGraphRand() {
    // const ns = `${this._props.dbName}.${this._props.accountsSim}`;
    const FORMAT = 'JSONEachRow'; //
    logger.time('scanStream');
    logger.time('build100000');
    const results = await this.client.request(this.gSql.structNodesSim());
    assert.equal(results.statusCode, 200);
    const counterTrx = { parents: 0, children: 0 };
    const funcTrx = async (row) => {
      // logger.inspectIt({ row });
      counterTrx.parents += 1;
      if (counterTrx.parents % 100000 === 0) { logger.timeEnd('build100000'); logger.dir({ counterTrx }); logger.time('build100000'); }
      const parent = JSON.parse(row);
      const parentDtCr = dtToUtc(new Date(parent.dtCr));
      const limit = ~~(Math.log(this._sim.accountsCount * parent.expectC) ** 3);   //  Math.round((this._sim.accountsCount * parent.expectC)  );
      const sqlStr = `SELECT * FROM ${this._sim.nsSimAccounts} WHERE id != ${parent.id} ORDER BY rand() ASC LIMIT ${limit} FORMAT JSON`;
      const result = await this.client.request(sqlStr);
      const rt = result.body.data.map((child) => {
        const childDtCr = dtToUtc(new Date(child.dtCr));
        let dt = new Date((parentDtCr > childDtCr) ? parentDtCr : childDtCr);
        dt = dtOffsetMinutes(dt, rndWithinInt(10, 1440)); // give it a random offset of < 1 day
        dt.setMilliseconds(0);
        const rtArr = [{ parent: parent.id, child: child.id, sign: 1, dtCr: dt / 1000 }];
        if (Math.random() < 0.1) {
          rtArr.push({ parent: child.id, child: parent.id, sign: 1, dtCr: dt / 1000 });  // make sure we have some mutual
        }
        if (Math.random() < 0.1) {
          dt = dtOffsetMinutes(dt, 1440);
          rtArr.push({ parent: parent.id, child: child.id, sign: -1, dtCr: dt / 1000 }); // unregister 10%
          if (Math.random() < 0.2) {
            dt = dtOffsetMinutes(dt, 1440);
            rtArr.push({ parent: parent.id, child: child.id, sign: 1, dtCr: dt / 1000 }); // re-register 20% of unregistered
          }
        }
        counterTrx.children += rtArr.length;
        return rtArr.map((el) => JSON.stringify(el));
      });
      return rt.flat();
      // logger.inspectIt({ input, result });
    };

    logger.time('buildGraph');
    const transformStream = new TransformParseRaw(FORMAT, { funcTrx });
    // transformStream.on('error', { }); 
    // ------------
    // const columns = columnsFromStructStr(structAccountsSim);
    const sqlArr = sql.INSERT_INTO(undefined, `${this.ns.edges}`, transformStream, { columns: '', FORMAT });
    // console.dir({ sqlArr, FORMAT})
    let resultsOut = this.client.request(...sqlArr);
    // ------------
    const sqlStr = `SELECT * FROM ${this._sim.nsSimAccounts} ORDER BY id ASC FORMAT ${FORMAT}`;
    const resultReader = await this.client.request(sqlStr, '', { flags: flagsCH.flagsToNum(['throwClient', 'throwNon200']) }); // don't resolve;
    await pipeline(resultReader.body, transformStream); // process.stdout)
    resultsOut = await resultsOut; // if we want to check results do an await here after stream ends;
    // logger.dir({ resultsOut });
    assert.equal(resultsOut.statusCode, 200);
    logger.timeEnd('buildGraph');
    // logger.inspectIt({ bodyStr }, 'bodySTr ------------------')
    return { counterStream: transformStream.counters, counterTrx };
  }

  async simInsertAccounts(count = this._sim.accountsCount) {
    // rndWithin = (min, max, rndFun = Math.random, ...args)
    // rndWithin = (min, max, rndFun = Math.random, ...args)
    // const columns = columnsFromStructStr(this.graphSql.structAccountsSim());
    const dateRandom = new DateRandom(new Date('2021-01-01'), new Date('2021-12-30'), rndExponentialInv, 18, 1);
    let cntCurrent = 0;
    const dataFn = () => {
      // eslint-disable-next-line no-cond-assign
      if ((cntCurrent += 1) <= count) {
        const dt = ~~(dateRandom.randomDt().getTime() / 1000);
        const expectC = rndWithin(0, 0.3, rndNormal).toFixed(2);
        const expectP = rndWithin(0, 0.3, rndNormal).toFixed(2);
        const values = `${cntCurrent}, ${dt}, ${expectC}, ${expectP}\n`;
        // console.log('val', values);
        return values;
      }
      return null;
    };